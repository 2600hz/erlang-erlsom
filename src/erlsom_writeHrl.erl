%%% Copyright (C) 2006 - 2008 Willem de Jong
%%%
%%% This file is part of Erlsom.
%%%
%%% Erlsom is free software: you can redistribute it and/or modify
%%% it under the terms of the GNU Lesser General Public License as 
%%% published by the Free Software Foundation, either version 3 of 
%%% the License, or (at your option) any later version.
%%%
%%% Erlsom is distributed in the hope that it will be useful,
%%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%%% GNU Lesser General Public License for more details.
%%%
%%% You should have received a copy of the GNU Lesser General Public 
%%% License along with Erlsom.  If not, see 
%%% <http://www.gnu.org/licenses/>.
%%%
%%% Author contact: w.a.de.jong@gmail.com

%%% ====================================================================
%%% Writes record definitions, to be used with Erlsom.
%%% ====================================================================

%%% Writes record defintions, taking a 'model' (from erlsom_compile) as
%%% input.

-module(erlsom_writeHrl).
-export([writeHrl/1]).
-export([writeHrlFile/3]).
-export([writeXsdHrlFile/2]).

-include("erlsom_parse.hrl").
-include("erlsom.hrl").

%% debug(Text) -> io:format("writeHrl: ~p~n", [Text]).

%% debug(Text1, Text2) ->
  %% io:format("~p ~p~n", [Text1, Text2]).

writeHrl(#model{tps = Types}) ->
  Acc = header(),
  writeTypes(Types, Acc).

writeHrlFile(Xsd, Prefix, Namespaces) ->
%% compile file
  Result = erlsom:compile(Xsd, Prefix, Namespaces),
  case Result of
    {ok, Model} -> 
      writeHrl(Model);
    {error, Error} -> 
      io:format("Error while compiling file: ~p~n", [Error])
  end.

writeXsdHrlFile(Xsd, Options) ->
%% compile file
  Result = erlsom:compile_xsd(Xsd, Options),
  case Result of
    {ok, Model} -> 
      writeHrl(Model);
    {error, Error} -> 
      throw({error, Error})
  end.

header() ->
"%% HRL file generated by ERLSOM\n"
"%%\n"
"%% It is possible to change the name of the record fields.\n"
"%%\n"
"%% It is possible to add default values, but be aware that these will\n"
"%% only be used when *writing* an xml document.\n\n".

writeTypes(Types, Acc) ->
  Acc ++ lists:foldl(fun writeType/2, [], erlsom_lib:unique(Types)).

writeType(#type{nm = '_document'}, Acc) ->
  Acc;
%% writeType(Type, []) -> writeType2(Type);
writeType(Type, Acc) ->
  Acc ++ writeType2(Type).

writeType2(#type{nm = Name, els = Elements, atts = Attributes}) ->
  Format = "~3n-record(~p, {anyAttribs :: proplist:proplist() | undefined~s~s})."
           "~2n-type ~s :: ~s.",
  Args   = [Name, writeAttributes(Attributes), writeElements(Elements),
            formatType(Name), formatRecord(Name)],
  lists:flatten(io_lib:format(Format, Args)).

writeElements(Elements) ->
  writeElements(Elements, 0).

writeElements([], _) ->
  [];
writeElements([Element | Tail], CountChoices) ->
  {Elem, CountChoices2} = writeElement(Element, CountChoices),
  NextElems = writeElements(Tail, CountChoices2),
  [",\n\t", Elem, NextElems].

writeElement(#el{alts = Alternatives}, CountChoices) ->
  writeAlternatives(Alternatives, CountChoices).

%% easy case: 1 alternative (not a choice), 'real' element (not a group)
%% FIXME: Collision with same names, but different prefixes.
%%        For exampes, names are ns1:name, ns2:name, record is {name, name}.
writeAlternatives([], CountChoices) ->
  {"any_strict_but_none_defined", CountChoices};
writeAlternatives([#alt{tag = '#any'}], CountChoices) ->
  {"any", CountChoices};
writeAlternatives([#alt{tag = Tag, rl = true, tp = {_,_}}], CountChoices) ->
  {"'" ++ erlsom_lib:nameWithoutPrefix(atom_to_list(Tag)) ++ "'", CountChoices};
writeAlternatives([A = #alt{tag = Tag, rl = true}], CountChoices) ->
  %% <xs:sequence>                                  
  %%   <xs:element minOccurs="0" ref="viz:spells"/> 
  %% </xs:sequence>                                 
  #alt{tp = Type, mn = Min, mx = Max} = A,
  Format = "%% Choice (xs:sequence)."
           "~n\t~p :: ~s | undefined",
           Args = [tagName(Tag), formatListType(Type, Min, Max)],
%% TODO: delete the flatten call.
  Field = io_lib:format(Format, Args),
  {Field, CountChoices};
writeAlternatives([#alt{tag = Tag, rl = false, tp = {_,_}}], CountChoices) ->
  {"'" ++ erlsom_lib:nameWithoutPrefix(atom_to_list(Tag)) ++ "'", CountChoices};
writeAlternatives([#alt{rl = false, tp=Tp}], CountChoices) ->
  {"'" ++ erlsom_lib:nameWithoutPrefix(atom_to_list(Tp)) ++ "'", CountChoices};
%% more than 1 alternative: a choice
writeAlternatives([#alt{} | _Tail] = Alts, CountChoices) ->
  Name = case CountChoices of
         0 ->
           "choice";
         _ -> 
           "choice" ++ integer_to_list(CountChoices)
       end,
  Acc2 = lists:flatten(io_lib:format("~s :: ~s | undefined", 
                                     [Name, writeTypeAlts(Alts)])),
  {Acc2, CountChoices + 1}.
      
writeTypeAlts(Alts) ->
    Types = [formatType(Type) ||  #alt{tp = Type} <- Alts],
    io_lib:format("[~s]", [joinTypes(erlsom_lib:unique(Types))]).


formatRecord(Type) ->
    io_lib:format("#~p{}", [Type]).

formatType(Type) ->
    io_lib:format("~p()", [Type]).

%% TODO: delete the flatten call.
writeAttributes(Attributes) ->
   lists:flatten(lists:map(fun writeAttribute/1, Attributes)).


-spec writeAttribute(#att{}) -> Acc when Acc :: iolist().

%% TODO: write type as a comment or as a type definition.
writeAttribute(#att{nm = Name, opt = Optional, tp = _Type}) -> 
    OptOrReq = if Optional -> "optional"; true -> "required" end,
    Format = ","
             "~n\t%% This attribute is ~s."
             "~n\t~p",
    io_lib:format(Format, [OptOrReq, Name]).


tagName(Tag) ->
    list_to_atom(erlsom_lib:nameWithoutPrefix(atom_to_list(Tag))).


-spec joinTypes([iolist()]) -> iolist().
joinTypes([H|T]) -> [H|joinTypes2(T)];
joinTypes([])    -> "".

joinTypes2([H|T]) -> [" | ", H | joinTypes2(T)];
joinTypes2([])    -> "".


-spec formatListType(Type, Min, Max) -> iolist() when
    Type :: atom(),
    Min :: Num,
    Max :: Num,
    Num :: undefined | non_neg_integer().

formatListType(Type, 1, _Max) ->
    io_lib:format("[~s]", [formatType(Type)]);

formatListType(Type, _Min, _Max) ->
    io_lib:format("[~s, ...]", [formatType(Type)]).
